#pragma once
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#define BADPTR 1
#define BADCURSZ 2
#define BADMAXSZ 3
#define EMPTYPOP 4
#define CANST1 5
#define CANST2 6
#define CANVALS1 7
#define CANVALS2 8

const uint64_t canaryVal = 0xD18AD0B5D18AD18C;

Stack::Stack(int _elSize):
    canaryStat1(canaryVal),
    begPointer(nullptr),
    elSize(_elSize),
    currentSize(0),
    maxSize(1),
    poison(0xEEEEEEEEEEEEEEEE),
    canaryStat2(canaryVal) {
        begPointer = malloc( (16 + _elSize) + (8 - _elSize % 8));
        if( begPointer == nullptr ){
            throw BADPTR;
        }
        else{
            *(uint64_t*) begPointer = canaryVal;
            *(uint64_t*) (begPointer + 8 + _elSize + ( 8 -  _elSize % 8 )) = canaryVal;
            begPointer += 8;
            fillPoison(begPointer);
        }
}

Stack::Stack(int _elSize, int _maxSize):
    canaryStat1(canaryVal),
    begPointer(nullptr),
    elSize(_elSize),
    currentSize(0),
    maxSize(_maxSize),
    poison(0xEEEEEEEEEEEEEEEE),
    canaryStat2(canaryVal) {
        begPointer = malloc(_maxSize * _elSize + 16 + (8 - (_maxSize * _elSize) % 8));
        if( begPointer == nullptr ){
            throw BADPTR;
        }
        else{
            *(uint64_t*) begPointer = canaryVal;
            *(uint64_t*) (begPointer + 8 + _maxSize * _elSize + (8 - (_maxSize * _elSize) % 8)) = canaryVal;
            begPointer += 8;
            for(int i = 0; i < _maxSize; i++) fillPoison(begPointer + i*_elSize);
        }
}


Stack::~Stack(){
        free(begPointer);
        begPointer = (void*) -1;
        currentSize = 0;
        maxSize = 0;
}

void Stack::pop(void* ptr){
    this -> checkStack();

    if( this -> currentSize > 0 ){
        uint8_t* charptr = (uint8_t*) ptr;
        for(int i = 0; i < (this -> elSize); i++){
            *(charptr + i) = *( (uint8_t*) ((this -> begPointer) + (this -> currentSize - 1) * (this -> elSize) + i));  
        }
        fillPoison((this -> begPointer) + (this -> currentSize - 1) * (this -> elSize));
        (this -> currentSize)--;        
    }
    else throw EMPTYPOP;    

    this  -> checkStack();

}

void Stack::push(void* ptr){
    
    this -> checkStack();

    if( (this -> currentSize) >= (this -> maxSize) - 2 ){
        this -> begPointer = realloc(this -> begPointer, 2 * (this -> maxSize) * (this -> elSize));
        if( (this -> begPointer == nullptr) ) throw BADPTR;

        this -> maxSize = 2 * (this -> maxSize);

        for(int i = (this -> currentSize); i < (this -> maxSize); i++){
            fillPoison(begPointer + i * (this -> elSize));
        }

    }

    for(int i = 0; i < (this -> elSize); i++){
        *( (uint8_t*) begPointer + (this -> currentSize) * (this -> elSize) + i) = *( (uint8_t*) ptr + i);
    }

    (this -> currentSize)++;

    this -> checkStack();

}

int Stack::decodeErr(int err){
    switch( err ) {
            case BADPTR:     printf("STACK ERROR: Pointer on stack beginning not initialized or NULL. Stack might have been deleted.\n"); break;
            case BADCURSZ:   printf("STACK ERROR: Current stack size (number of elements) exceeds max size\n"); break;
            case BADMAXSZ:   printf("STACK ERROR: Max stack size (max number of elements) below or equals zero;\n"); break;
            case EMPTYPOP:   printf("STACK ERROR: Pop was called on an empty stack\n"); break;
            case CANST1:     printf("STACK ERROR: First canary of the stack data was corrupted\n"); break;
            case CANST2:     printf("STACK ERROR: Second canary of the stack data was corrupted\n"); break;
            case CANVALS1:   printf("STACK ERROR: First canary of the actual stack contents was corrupted\n"); break;
            case CANVALS2:   printf("STACK ERROR: Second canary of the actual stack contents was corrupted\n"); break;
            default:         printf("You've caught an unknown exception. Seems like it was not generated by the stack\n"); return 1; break;
    }

    return 0;
}

void Stack::dump(){
    this -> checkStack();
        
    printf("---------------------Stack dump---------------------\n");
    printf("Stack dump\n");
    printf("Stack addr:\t%p\n", this);
    printf("Poison value:\t0x%lX\n", this -> poison);
    printf("\nStruct dump:\n");
    printf("\tPointer on stack beginning:\t%p\n", this -> begPointer);
    printf("\tCurrent stack size:\t        %d\n", this -> currentSize);
    printf("\tMax stack size:\t  \t        %d\n", this -> maxSize);
    printf("\nContents dump:\n");
    for( int i = 0; i < (this -> maxSize); i++){ 
        if( i == (this -> currentSize) ) printf("cur -> ");
        printf("\t[%d]:\t", i);
        for(int k = 0; k < (this -> elSize); k++){
            uint8_t val = *( (uint8_t*) this -> begPointer + i*(this -> elSize) + k); 
            if( val <= 0xF ) printf("0");
            printf("%X ", val);
        }
        if( checkPoison((this -> begPointer) + i*(this -> elSize)) == 1  ) printf(" : POISON\n");
        else printf("\n");    
    }
    printf("----------------------------------------------------\n");
}

void Stack::checkStack(){
    if( (this -> begPointer == (void*) -1) || (this -> begPointer == NULL) ) throw BADPTR;
    else if( this -> canaryStat1 != canaryVal ) throw CANST1;
    else if( this -> canaryStat2 != canaryVal ) throw CANST2;
    else if( (this -> currentSize < 0) || (this -> currentSize > this -> maxSize) ) throw BADCURSZ;
    else if( this -> maxSize <= 0 ) throw BADMAXSZ;
}

int Stack::checkPoison(void* ptr){
    for(int i = 0;( i < (this -> elSize) ) && ( i < 8 ); i++){
        if( *((uint8_t*)(ptr + i)) != (this -> poison) << (7 - i) * 8 >> 56) return 0;
    }
    return 1;   
}

void Stack::fillPoison(void* ptr){
    uint8_t* charptr = (uint8_t*) ptr;
    for(int i = 0;( i < (this -> elSize) ) && ( i < 8 ); i++){
        *(charptr + i) = (this -> poison) << (7 - i) * 8 >> 56;
    }
}










